$date
	Mon Sep 15 12:05:01 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module riscv_tb $end
$var reg 1 ! clk $end
$var reg 1 " reset $end
$scope module core $end
$var wire 1 ! clk $end
$var wire 1 " reset $end
$var wire 1 # mem_store_en $end
$var wire 1 $ mem_load_en $end
$var wire 32 % mem_load_data [31:0] $end
$var wire 32 & if_pc [31:0] $end
$var wire 32 ' if_instruction [31:0] $end
$var wire 5 ( id_rs2 [4:0] $end
$var wire 5 ) id_rs1 [4:0] $end
$var wire 5 * id_rd [4:0] $end
$var wire 7 + id_opcode [6:0] $end
$var wire 32 , id_imm [31:0] $end
$var wire 7 - id_fun7 [6:0] $end
$var wire 3 . id_fun3 [2:0] $end
$var wire 1 / ex_write_reg $end
$var wire 32 0 ex_op2 [31:0] $end
$var wire 32 1 ex_op1 [31:0] $end
$var wire 1 2 ex_jump_inst $end
$var wire 1 3 ex_branch_inst $end
$var wire 32 4 ex_alu_result [31:0] $end
$scope module DEC $end
$var wire 3 5 fun3_o [2:0] $end
$var wire 7 6 fun7_o [6:0] $end
$var wire 7 7 opcode_o [6:0] $end
$var wire 5 8 rd_o [4:0] $end
$var wire 5 9 rs1_o [4:0] $end
$var wire 5 : rs2_o [4:0] $end
$var wire 5 ; rs2 [4:0] $end
$var wire 5 < rs1 [4:0] $end
$var wire 5 = rd [4:0] $end
$var wire 7 > opcode [6:0] $end
$var wire 32 ? instruction [31:0] $end
$var wire 32 @ imm_o [31:0] $end
$var wire 7 A fun7 [6:0] $end
$var wire 3 B fun3 [2:0] $end
$upscope $end
$scope module DMEM $end
$var wire 1 ! clk $end
$var wire 32 C loadData_w [31:0] $end
$var wire 1 $ load_en $end
$var wire 1 " reset $end
$var wire 1 # store_en $end
$var wire 32 D storeData [31:0] $end
$var wire 32 E address_i [31:0] $end
$var reg 32 F loadData_reg [31:0] $end
$var integer 32 G i [31:0] $end
$upscope $end
$scope module EXEC $end
$var wire 1 3 branch_inst_wire $end
$var wire 3 H fun3_i [2:0] $end
$var wire 7 I fun7_i [6:0] $end
$var wire 1 ! i_clk $end
$var wire 1 J i_en $end
$var wire 32 K imm_i [31:0] $end
$var wire 32 L imm_i_signed [31:0] $end
$var wire 1 2 jump_inst_wire $end
$var wire 7 M opcode_i [6:0] $end
$var wire 32 N operand1_pi_signed [31:0] $end
$var wire 32 O operand2_pi_signed [31:0] $end
$var wire 5 P rd_i [4:0] $end
$var wire 1 / write_reg_file_wire $end
$var wire 32 Q pc_i [31:0] $end
$var wire 32 R operand2_pi [31:0] $end
$var wire 32 S operand1_pi [31:0] $end
$var wire 32 T alu_result [31:0] $end
$var reg 1 3 branch_inst $end
$var reg 1 2 jump_inst $end
$var reg 33 U result [32:0] $end
$var reg 1 V write_reg_file $end
$upscope $end
$scope module IMEM $end
$var wire 1 ! clk $end
$var wire 1 " reset $end
$var wire 32 W pc_i [31:0] $end
$var wire 32 X instruction_o [31:0] $end
$var reg 32 Y instruction_o_reg [31:0] $end
$upscope $end
$scope module PC_unit $end
$var wire 1 3 branch_inst_wire $end
$var wire 1 Z change_PC_condition_for_jump_or_branch $end
$var wire 1 ! clk_i $end
$var wire 1 [ enable_design $end
$var wire 32 \ initial_pc_i [31:0] $end
$var wire 1 2 jump_inst_wire $end
$var wire 32 ] pc_o [31:0] $end
$var wire 1 ^ pc_valid $end
$var wire 1 " reset_i $end
$var wire 1 _ stage_IF_ready $end
$var wire 32 ` targetPC_i [31:0] $end
$var wire 32 a nextPC [31:0] $end
$var reg 32 b PC [31:0] $end
$var reg 1 c pc_valid_r $end
$upscope $end
$scope module REG_FILE $end
$var wire 1 ! clk $end
$var wire 5 d rd_addr [4:0] $end
$var wire 32 e rd_data [31:0] $end
$var wire 1 " reset $end
$var wire 5 f rs1_addr [4:0] $end
$var wire 5 g rs2_addr [4:0] $end
$var wire 1 / we_i $end
$var wire 32 h rs2_data [31:0] $end
$var wire 32 i rs1_data [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
bx i
bx h
bx g
bx f
bx e
bx d
xc
bx b
bx a
bx `
1_
1^
bx ]
b0 \
1[
xZ
bx Y
bx X
bx W
xV
bx U
bx T
bx S
bx R
bx Q
bx P
bx O
bx N
bx M
bx L
bx K
1J
bx I
bx H
bx G
bx F
bx E
bx D
bx C
bx B
bx A
bx @
bx ?
bx >
bx =
bx <
bx ;
bx :
bx 9
bx 8
bx 7
bx 6
bx 5
bx 4
x3
x2
bx 1
bx 0
x/
bx .
bx -
bx ,
bx +
bx *
bx )
bx (
bx '
bx &
bx %
x$
x#
1"
0!
$end
#5
b100 a
0Z
b0 4
b0 E
b0 T
b0 `
b0 e
0V
02
03
b0 U
0/
b0 O
b0 0
b0 D
b0 R
b0 h
b0 N
b0 1
b0 S
b0 i
b0 L
b0 ,
b0 @
b0 K
b0 -
b0 6
b0 I
b0 A
b0 (
b0 :
b0 g
b0 ;
b0 )
b0 9
b0 f
b0 <
b0 .
b0 5
b0 H
b0 B
b0 *
b0 8
b0 P
b0 d
b0 =
0#
0$
b0 +
b0 7
b0 M
b0 >
b0 &
b0 Q
b0 W
b0 ]
b0 b
1c
b0 '
b0 ?
b0 X
b0 Y
b10000000000 G
1!
#10
0!
#15
b10000000000 G
1!
#20
0!
0"
#25
bx O
bx 0
bx D
bx R
bx h
b1000 a
b1010 L
b1010 ,
b1010 @
b1010 K
b1010 (
b1010 :
b1010 g
b1010 ;
b1 *
b1 8
b1 P
b1 d
b1 =
b10011 +
b10011 7
b10011 M
b10011 >
b100 &
b100 Q
b100 W
b100 ]
b100 b
b101000000000000010010011 '
b101000000000000010010011 ?
b101000000000000010010011 X
b101000000000000010010011 Y
1!
#30
0!
#35
b10100 L
b10100 ,
b10100 @
b10100 K
b10100 (
b10100 :
b10100 g
b10100 ;
b10 *
b10 8
b10 P
b10 d
b10 =
b1100 a
b1010000000000000100010011 '
b1010000000000000100010011 ?
b1010000000000000100010011 X
b1010000000000000100010011 Y
b1000 &
b1000 Q
b1000 W
b1000 ]
b1000 b
1!
#40
0!
#45
b0 O
b0 0
b0 D
b0 R
b0 h
b10000 a
b10 L
b10 ,
b10 @
b10 K
b10 (
b10 :
b10 g
b10 ;
b1 )
b1 9
b1 f
b1 <
b11 *
b11 8
b11 P
b11 d
b11 =
b110011 +
b110011 7
b110011 M
b110011 >
b1100 &
b1100 Q
b1100 W
b1100 ]
b1100 b
b1000001000000110110011 '
b1000001000000110110011 ?
b1000001000000110110011 X
b1000001000000110110011 Y
1!
#50
0!
#55
b10000000001 L
b10000000001 ,
b10000000001 @
b10000000001 K
b100000 -
b100000 6
b100000 I
b100000 A
b1 (
b1 :
b1 g
b1 ;
b10 )
b10 9
b10 f
b10 <
b100 *
b100 8
b100 P
b100 d
b100 =
b10100 a
b1000000000100010000001000110011 '
b1000000000100010000001000110011 ?
b1000000000100010000001000110011 X
b1000000000100010000001000110011 Y
b10000 &
b10000 Q
b10000 W
b10000 ]
b10000 b
1!
#60
0!
#65
bx O
bx 0
bx D
bx R
bx h
b11000 a
b1111 L
b1111 ,
b1111 @
b1111 K
b0 -
b0 6
b0 I
b0 A
b1111 (
b1111 :
b1111 g
b1111 ;
b0 )
b0 9
b0 f
b0 <
b101 *
b101 8
b101 P
b101 d
b101 =
b10011 +
b10011 7
b10011 M
b10011 >
b10100 &
b10100 Q
b10100 W
b10100 ]
b10100 b
b111100000000001010010011 '
b111100000000001010010011 ?
b111100000000001010010011 X
b111100000000001010010011 Y
1!
#70
0!
#75
b11110000 L
b11110000 ,
b11110000 @
b11110000 K
b111 -
b111 6
b111 I
b111 A
b10000 (
b10000 :
b10000 g
b10000 ;
b110 *
b110 8
b110 P
b110 d
b110 =
b11100 a
b1111000000000000001100010011 '
b1111000000000000001100010011 ?
b1111000000000000001100010011 X
b1111000000000000001100010011 Y
b11000 &
b11000 Q
b11000 W
b11000 ]
b11000 b
1!
#80
0!
#85
bx N
bx 1
bx S
bx i
b100000 a
b1111 L
b1111 ,
b1111 @
b1111 K
b0 -
b0 6
b0 I
b0 A
b1111 (
b1111 :
b1111 g
b1111 ;
b110 )
b110 9
b110 f
b110 <
b111 .
b111 5
b111 H
b111 B
b111 *
b111 8
b111 P
b111 d
b111 =
b11100 &
b11100 Q
b11100 W
b11100 ]
b11100 b
b111100110111001110010011 '
b111100110111001110010011 ?
b111100110111001110010011 X
b111100110111001110010011 Y
1!
#90
0!
#95
b1010 L
b1010 ,
b1010 @
b1010 K
b1010 (
b1010 :
b1010 g
b1010 ;
b0 .
b0 5
b0 H
b0 B
b1000 *
b1000 8
b1000 P
b1000 d
b1000 =
b110011 +
b110011 7
b110011 M
b110011 >
b100100 a
b101000110000010000110011 '
b101000110000010000110011 ?
b101000110000010000110011 X
b101000110000010000110011 Y
b100000 &
b100000 Q
b100000 W
b100000 ]
b100000 b
1!
#100
0!
