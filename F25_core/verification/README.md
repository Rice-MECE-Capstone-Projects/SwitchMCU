# RISC-V Core + UVM Verification Infrastructure

## Overview
This repository contains the RTL implementation of a 5-stage RV32I core and three complementary verification environments:

TOP_CORE — a full-system simulation environment using BRAM-backed instruction and data memories.

EXECUTE_MODULE — a UVM testbench targeting the execute stage in isolation, enabling cycle-accurate validation of ALU behavior, branch comparison logic, and operand forwarding.

uvm_pc_tb — a UVM testbench for the program counter (PC), verifying sequential PC increments, branch redirection, and reset behavior.

The combination of these environments enables modular verification, subsystem-level bring-up, and complete full-core execution testing using RISC-V-DV–generated programs. The following folders include copies of child strcutures included in TOP_CORE:

CORE - RTL files used in core implementation 
CORE_SMOKE - Framework used specifically for running core smoke test

### NOTE FOR BELOW INSTRUCTIONS

If the project is new on this machine and you get “library work not found”, do in the Transcript once:

        vlib work
        vmap work work
        --> Compile All again

## TOP_CORE — Full RISC-V Core System Test Environment

TOP_CORE contains the infrastructure required to run full RISC-V programs on the RTL core using BRAM-based instruction and data memory models.

### Key Files

    bram_ins.sv / bram_mem.sv - Synthesizable BRAM wrappers for program and data memory.

    ins_mem_model.sv - Behavioral instruction memory model for faster simulation.

    program.hex - Instruction memory image generated by RISC-V-DV or written directly by user (currently set to DEADBEEF example).

    tb_smoke_riscv32i.sv - System-level testbench that instantiates the full core + memories.

    CORE - A snapshot of RTL modules (pc.v, decode.v, excute.v, hazard.v, etc.).

    CORE_TB - Support infrastructure for smoke tests, including core_if.sv and scoreboard utilities.

### Functionality

```TOP_CORE``` - executes complete RISC-V programs from reset through termination.
It validates:

1. PC progression across pipeline stages

2. Correct decode behavior

3. End-to-end execution of RISC-V-DV instruction streams

### How program.hex Is Used

At time 0, the BRAM instruction memory loads:

```$readmemh("program.hex", mem_array);```

## EXECUTE_MODULE - UVM Environment for the Execute Stage

EXECUTE_MODULE provides a full UVM environment dedicated to verifying the execute (ALU) stage of the RISC-V pipeline in isolation.

### Key Files

design.sv
    The isolated execute-stage DUT.

    execute_if.sv - Transaction-level interface connecting driver/monitor to the DUT.

    exec_driver.sv - Drives operands, ALU operation codes, and branch signals.

    exec_monitor.sv - Observes ALU outputs and comparison results.

    exec_scoreboard.sv - Compares DUT output against a golden behavioral ALU model.

    pkg_tx.sv - Defines UVM transaction objects for ALU stimulus.

    env.sv - UVM environment that instantiates driver, monitor, scoreboard, and analysis ports.

    my_test.sv - Example test generating randomized ALU operations.

### Functionality

This environment validates:

1. All ALU opcodes (add/sub, logic, shifts, set-less-than)

2. Branch compare results (BEQ, BLT, BGE, etc.)

3. Operand forwarding edge cases

4. Result correctness against a golden model

5. UVM-compliant driver/monitor/scoreboard behavior

This stage-level environment was used as the prototype for adopting UVM in the broader verification flow.

### Running the Execute-Stage UVM Testbench

The execute-stage UVM environment is located in ```EXECUTE_MODULE/```.
Questa provides an .mpf project file and a UVM testbench with the simulation top module tb_top.

Follow the steps below to open the project, compile the testbench, and launch the UVM test.

1. Open the Execute UVM Project in Questa

From the terminal:

    cd EXECUTE_MODULE
    vsim -gui EXECUTE.mpf

This opens the preconfigured Questa project.

2. Compile All Files

Once the project is open:

Option A - GUI

        Top menu:

        Compile → Compile All


All files should compile without errors.
You should see green checkmarks next to each source file.

Option B - Transcript command

In the Transcript window:

        project compileall

3. Load the Simulation Top

The execute-stage testbench top module is:

        tb_top


Load it in the Questa GUI:

        Simulate → Simulate…


Then choose:

        work.tb_top


Or run directly from the Transcript:

        vsim work.tb_top
        run -all
## uvm_pc_tb - UVM Environment for the Program Counter (PC)

The uvm_pc_tb directory contains a UVM testbench specifically targeting the PC module (pc.v).

### Key Files

    pc.v — The DUT

    pc_if.sv — PC interface for UVM components

    pc_driver.sv — Drives next-PC, enable, redirect signals

    pc_monitor.sv — Captures PC outputs each cycle

    pc_pkg.sv — Transaction & sequence definitions

    pc_seq.sv — Directed/random sequence generation

    pc_test.sv / pc_test_2.sv — UVM tests

    tb_top.sv — Top-level UVM testbench

### Functionality

The PC UVM environment validates:

1. Reset → PC=0 behavior

2. Sequential PC+4 increments

3. Immediate redirect on branch/jump target

4. Stall/hold behavior (when integrated later)

5. Correct interaction with redirect enable signals

This testbench ensures the PC module is correct before being integrated into the full pipeline.

### Running the PC Project

1. Open the PC UVM Project

From the terminal:

        cd uvm_pc_tb
        vsim -gui QUESTA_prj.mpf


This loads the preconfigured Questa project containing:

2. Compile All Files

After the project is open in the GUI:

Option A:


        Compile from GUI
        Compile → Compile All



3. Load the Simulation Top

The PC UVM simulation entry point is the module: ```tb_top```


Load it via:

        Simulate → Simulate → work.tb_top


or in the Transcript:

        vsim work.tb_top


4. Run the UVM Test

Start the test with:

        run -all




## How to Run Core Tests (scoreboard / smoke):

### Open the Project Structure (TOP_CORE.mpf)
1. Option A: From the terminal:

        cd TOP_CORE
        vsim -gui TOP_CORE.mpf


Questa will open with the project files already loaded.

2. Option B: From the GUI

        Start Questa/ModelSim normally (vsim & or from your menu).

        In the GUI: File → Open → Project…

        Navigate to TOP_CORE/.

        Select TOP_CORE.mpf and click Open.

### Compile the Project

From inside Questa with the project open:

        Top menu: Compile → Compile All
        OR
        vsim -c -do "project open TOP_CORE.mpf; project compileall; quit"


Watch the Transcript window; you want 0 errors.

If you change a file later (if you edit/regenerate your own program.hex file), recompile all to ensure functionality. 


### Run the Smoke Test (full core program execution)

The  full-core smoke test top is ```tb_smoke_riscv32i.sv```

1. GUI way (not recommended)

        In the Project window, find tb_smoke_riscv32i.sv.

        Right-click tb_smoke_riscv32i (the module name, not just the file) and select Simulate.

Questa will launch vsim work.tb_smoke_riscv32i.

In the Simulate/Transcript window, type:

        run -all


Watch the console output; this run uses:

        program.hex as the instruction image

        bram_ins.sv / bram_mem.sv and ins_mem_model.sv

        riscv32i.v as the DUT.

This is the “does the core run a RISC-V program?” test.

2. Command-line equivalent from inside vsim (recommended!!!)

In the Transcript:

        vsim work.tb_smoke_riscv32i
        run -all

Expect transcript output showing:

     ----- Smoke Test Start -----

Followed by stop sim assertion, time of end, iteration num ect. Use original program.hex file for this test. Sucessful assertion of stop sim confirms simple core function (writing of DEADBEEF to desired ending variable)
### Run the Decoder Scoreboard Test

The decoder scoreboard environment is driven by tb_decoder_scoreboard.sv and uses 

```decoder_scoreboard.sv, golden_decoder.sv, core_smoke_test_pkg.sv, core_smoke_test.sv, core_if.sv.```

1. GUI way (not recommended)

        In the Project window, locate ```tb_decoder_scoreboard.sv.```
        Right-click the tb_decoder_scoreboard module and select Simulate.

        In the Transcript, run:

        run -all


This test:

Instantiates the core

Uses core_if.sv as an interface

Compares decode outputs from ```riscv32i.v``` against ```golden_decoder.sv```

Reports mismatches via decoder_scoreboard.sv.

2. Command-line equivalent (recommended!!!)

        vsim work.tb_decoder_scoreboard
        run -all



### Switching Between Tests

Typical workflow:

        Compile All after edits.

To run smoke:

        vsim -voptargs=+acc work.tb_smoke_riscv32i
        run -all

To run decoder scoreboard:

        vsim -voptargs=+acc work.tb_decoder_scoreboard
        run -all


## RISC-V-DV Integration and Program Generation

RISC-V-DV is used in this project to generate simple ALU-only instruction programs that are executed in the TOP_CORE environment. These programs test the decode stage behavior inside the full pipeline without introducing branches, loads/stores, or CSR instructions.

Below is the minimal setup and workflow.

### 1. Install and Set Up RISC-V-DV: 
Clone the repository

```git clone https://github.com/google/riscv-dv.git```

```cd riscv-dv```

### 2. Install Python dependencies
```pip install -r requirements.txt```

### 3. Install RISC-V GCC toolchain

You need riscv32-unknown-elf-gcc and objcopy.

```sudo apt install gcc-riscv64-unknown-elf```

### 4. Verify installation
```riscv32-unknown-elf-gcc --version```

```python3 run.py --help```


At this point, RISC-V-DV is fully installed.

### 5. Generate ALU-Only RV32I Assembly Tests

Run the generator with constraints that disable everything except execute-stage ops:

```
python3 run.py \
    --test riscv_rand_instr_test \
    --isa rv32i \
    --instr_cnt=200 \
    --no_load_store \
    --no_branch_jump \
    --no_csr_instr

```
This produces RV32I assembly programs such as:
```
out_0.S
```

Each file contains only instructions like ADD, SUB, AND, OR, SLT, shifts, etc.

### 6. Compile the Assembly to ELF
```
riscv32-unknown-elf-gcc -march=rv32i -mabi=ilp32 \
    -nostdlib -T linker.ld \
    out_0.S -o out_0.elf
```

You may use a simple linker script such as:
```
ENTRY(_start)
SECTIONS {
  . = 0x0;
  .text : { *(.text*) }
}
```
### 7. Convert ELF → Verilog-Compatible HEX
```
riscv32-unknown-elf-objcopy -O verilog out_0.elf out_0.hex
```
The resulting file looks like:
```
00b50533
403505b3
00c58633
...
```

Each line is a 32-bit instruction word.

### 8. Load Into the TOP_CORE Testbench

Copy into your simulation directory:
```
cp out_0.hex TOP_CORE/program.hex
```

Then run TOP_CORE testing as described in its section


